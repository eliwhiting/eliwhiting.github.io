<html>

<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
    <title>3D Game Design</title>
    <script src="cannon.js"></script>
    <script src="babylon.js"></script>
    <script src="babylon.objFileLoader.min.js"></script>
    <script>
        function start(){
        
				//ALL YOUR CODE GOES IN HERE
			var canvas = document.getElementById('renderCanvas'); 
			var engine = new BABYLON.Engine(canvas, true);

			var scene = new BABYLON.Scene(engine);
			var keys = {};

			window.addEventListener('keydown', function(e) {

			keys[e.key] = true;

			});

			

			window.addEventListener('keyup', function(e) {

			keys[e.key] = false;

			});	
			var gravityVector = new BABYLON.Vector3(0, -9.81, 0);

			scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin()); 




			scene.clearColor = new BABYLON.Color3(0, 0, 0);

			//===TRACK CODE===//
var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.025)+(3*t*Math.pow((1-t),2)*0.18)+(3*Math.pow(t,2)*(1-t)*0.3525)+(Math.pow(t,3)*0.56)},function(t) {return (Math.pow((1-t),3)*0.56)+(3*t*Math.pow((1-t),2)*0.7675)+(3*Math.pow(t,2)*(1-t)*0.095)+(Math.pow(t,3)*0.1275)},function(t) {return (Math.pow((1-t),3)*0.1275)+(3*t*Math.pow((1-t),2)*0.16)+(3*Math.pow(t,2)*(1-t)*0.8725)+(Math.pow(t,3)*0.7325)},function(t) {return (Math.pow((1-t),3)*0.7325)+(3*t*Math.pow((1-t),2)*0.5925)+(3*Math.pow(t,2)*(1-t)*0.845)+(Math.pow(t,3)*0.88)},function(t) {return (Math.pow((1-t),3)*0.88)+(3*t*Math.pow((1-t),2)*0.915)+(3*Math.pow(t,2)*(1-t)*0.575)+(Math.pow(t,3)*0.7775)},function(t) {return (Math.pow((1-t),3)*0.7775)+(3*t*Math.pow((1-t),2)*0.98)+(3*Math.pow(t,2)*(1-t)*0.4775)+(Math.pow(t,3)*0.17)},function(t) {return (Math.pow((1-t),3)*0.17)+(3*t*Math.pow((1-t),2)*-0.1375)+(3*Math.pow(t,2)*(1-t)*0.255)+(Math.pow(t,3)*0.255)},function(t) {return (Math.pow((1-t),3)*0.255)+(3*t*Math.pow((1-t),2)*0.255)+(3*Math.pow(t,2)*(1-t)*0.0075)+(Math.pow(t,3)*0.3975)},function(t) {return (Math.pow((1-t),3)*0.3975)+(3*t*Math.pow((1-t),2)*0.7875)+(3*Math.pow(t,2)*(1-t)*0.1475)+(Math.pow(t,3)*0.025)}];var i = Math.max(0,Math.min(8, Math.floor(t * 9)));return fns[i]((t - (i/9)) * 9);};

var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.2)+(3*t*Math.pow((1-t),2)*0.2353125)+(3*Math.pow(t,2)*(1-t)*0.2053125)+(Math.pow(t,3)*0.3928125)},function(t) {return (Math.pow((1-t),3)*0.3928125)+(3*t*Math.pow((1-t),2)*0.5803125)+(3*Math.pow(t,2)*(1-t)*0.2753125)+(Math.pow(t,3)*0.3578125)},function(t) {return (Math.pow((1-t),3)*0.3578125)+(3*t*Math.pow((1-t),2)*0.4403125)+(3*Math.pow(t,2)*(1-t)*0.9503125)+(Math.pow(t,3)*0.3628125)},function(t) {return (Math.pow((1-t),3)*0.3628125)+(3*t*Math.pow((1-t),2)*-0.2246875)+(3*Math.pow(t,2)*(1-t)*0.4653125)+(Math.pow(t,3)*0.6803125)},function(t) {return (Math.pow((1-t),3)*0.6803125)+(3*t*Math.pow((1-t),2)*0.8953125)+(3*Math.pow(t,2)*(1-t)*0.7653125)+(Math.pow(t,3)*0.8928125)},function(t) {return (Math.pow((1-t),3)*0.8928125)+(3*t*Math.pow((1-t),2)*1.0203125)+(3*Math.pow(t,2)*(1-t)*0.6428125)+(Math.pow(t,3)*0.8753125)},function(t) {return (Math.pow((1-t),3)*0.8753125)+(3*t*Math.pow((1-t),2)*1.1078125)+(3*Math.pow(t,2)*(1-t)*0.7103125)+(Math.pow(t,3)*0.7103125)},function(t) {return (Math.pow((1-t),3)*0.7103125)+(3*t*Math.pow((1-t),2)*0.7103125)+(3*Math.pow(t,2)*(1-t)*0.5878125)+(Math.pow(t,3)*0.7053125)},function(t) {return (Math.pow((1-t),3)*0.7053125)+(3*t*Math.pow((1-t),2)*0.8228125)+(3*Math.pow(t,2)*(1-t)*0.5503125)+(Math.pow(t,3)*0.5278125)}];var i = Math.max(0,Math.min(8, Math.floor(t * 9)));return fns[i]((t - (i/9)) * 9);};
/* START CURVE DATA 
{"start":[33,30.125],"init":[328,346.125],"segments":[{"a":[326,41.125],"b":[248,19.125]},{"a":[70,119.125],"b":[203,147.125]},{"a":[264,75.125],"b":[257,52.125]},{"a":[178,11.125],"b":[168,83.125]},{"a":[240,142.125],"b":[258,110.125]},{"a":[242,54.125],"b":[219,47.125]},{"a":[176,62.125],"b":[187,98.125]},{"a":[233,124.125],"b":[246,96.125]},{"a":[227,49.125],"b":[201,58.125]},{"a":[202,112.125],"b":[215,105.125]},{"a":[242,100.125],"b":[231,73.125]},{"a":[196,66.125],"b":[215,88.125]}]}

   END CURVE DATA */



			//===END TRACK CODE===// 

			var xFn = function(t) { return 650 * _xFn(t); }
			var zFn = function(t) { return 650 * _yFn(t); } 

			var playerSphere = BABYLON.MeshBuilder.CreateSphere("playerSphere", {
				segments: 12,
				diameter: 4
			}, scene);

			playerSphere.material = new BABYLON.StandardMaterial("playerSphereMaterial", scene);
			playerSphere.material.diffuseTexture = new BABYLON.Texture('resources/BeachBallColor.jpg', scene);
			playerSphere.position = new BABYLON.Vector3(xFn(0), 9, zFn(0)); 


			playerSphere.physicsImpostor = new BABYLON.PhysicsImpostor(playerSphere, BABYLON.PhysicsImpostor.SphereImpostor, {
			mass: 1,
			restitution: 0.9
		}, scene);


		BABYLON.SceneLoader.ImportMesh(null, "resources/", "speed.obj", scene, function(meshes) {
			var boostMesh = meshes[0], boosts = [];
			boostMesh.material = new BABYLON.StandardMaterial("boostMaterial", scene);
			boostMesh.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
			boostMesh.scaling = new BABYLON.Vector3(5, 5, 5);
			boostMesh.setEnabled(false);
			function boostAt(xFn, zFn, t) {
			var newBoost = boostMesh.clone('boost');
			newBoost.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));
			newBoost.rotation.y = -derivAngle(t, xFn, zFn);
			newBoost.setEnabled(true);
			boosts.push(newBoost);
		}

		// Place boosts here//
	




		scene.registerAfterRender(function() {
		boosts.forEach(function(boost, i){
		if(boost.intersectsMesh(playerSphere)){
			boost.dispose();
			boosts.splice(i,1);
			var vel = playerSphere.physicsImpostor.getLinearVelocity();
			playerSphere.applyImpulse(vel.normalize().scale(100), playerSphere.getAbsolutePosition());
		} 
		else {
		boost.rotation.y += 0.01
		}
	});
	});
	}); 


			var camera = new BABYLON.ArcRotateCamera("Camera", 0, (3 * Math.PI) / 8, 20, playerSphere, scene); 
			camera.attachControl(canvas, true);

			var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);

			rampAt(xFn, zFn, 100.89, -Math.PI / 4, scene);
			 

			wallAt(xFn, zFn, 9.20, -6.1, scene);

			var startTime;
			var timer = document.querySelector('#timer');

			scene.registerAfterRender(function() { 

				
				var vel = playerSphere.physicsImpostor.getLinearVelocity();

				playerSphere.physicsImpostor.setLinearVelocity(vel.scale(.98)); 

				

				var forward = camera.getFrontPosition(1).subtract(camera.position);

				forward.y = 0;

				forward = forward.normalize().scale(1); 

				

				var backward = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI));

				

				var left = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY((3 * Math.PI) / 2));

				

				var right = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI / 2));

				

				if (keys.w) {

				if(!startTime){ startTime = Date.now(); } 

				playerSphere.applyImpulse(forward, playerSphere.getAbsolutePosition());

				}

				if (keys.s) {

				playerSphere.applyImpulse(backward, playerSphere.getAbsolutePosition());

				}

				if (keys.a) {

				playerSphere.applyImpulse(left, playerSphere.getAbsolutePosition());

				}

				if (keys.d) {

				playerSphere.applyImpulse(right, playerSphere.getAbsolutePosition());

				} 
				var currentT = tLookup(xFn, zFn, 700, playerSphere.position.x, playerSphere.position.z);
				
				 
var angle = (derivAngle(currentT, xFn, zFn) - (Math.PI)); 

camera.alpha += (angle - camera.alpha) / 32; 


				if (currentT > 0.99) {

				win();

				} 

				if (playerSphere.position.y < -5) {
					lost();
				} 

			if(startTime) {
			timer.innerHTML = ((Date.now() - startTime) / 1000).toFixed(2).replace('.',':');
			} 

			});	
			function drawPoint(x, z, zrot, scene) {

				var point = BABYLON.MeshBuilder.CreateBox('point', { 
				width: 10, 
				height: 0.5, 
				depth: 12 
				}, scene);

				point.material = new BABYLON.StandardMaterial("pointMaterial", scene);
				point.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
				point.position = new BABYLON.Vector3(x, 0.1, z);
				point.rotation.y = zrot;
				point.physicsImpostor = new BABYLON.PhysicsImpostor(point, BABYLON.PhysicsImpostor.BoxImpostor, {
					mass: 0,
					restitution: 0.9
				}, scene);

			}//end drawpoint

			function drawParametric(xFn, zFn, start, end, res, scene) {

				for (var t = start; t <= end; t += ((end - start) / res)) {

					drawPoint(xFn(t), zFn(t), 0, scene);

			}

			} 
			 drawParametric(xFn, zFn, 0, 1, 700, scene); 
			function tLookup(xFn, zFn, res, x, z) {

			var minT = 0;

			var minDist = Infinity;

			for (var t = 0; t <= 1; t += (1 / res)) {

			var dist = Math.pow(x - xFn(t), 2) + Math.pow(z - zFn(t), 2);

			if (dist < minDist) {

			minDist = dist;

			minT = t;

			}

			}

			return minT;

			} 


			function derivAngle(t, xFn, zFn) {

			function derive(f, x) {

			var h = 2.2e-10;

			return (f(x + h) - f(x - h)) / (2 * h);

			}

			return Math.atan2(derive(zFn, t), derive(xFn, t));

			} 


			function rampAt(xFn, zFn, t, angle, scene) {

			var ramp = BABYLON.MeshBuilder.CreateBox('ramp', {

			height: 8,

			width: .25,

			depth: 12

			}, scene);

			ramp.material = new BABYLON.StandardMaterial("rampMaterial", scene);

			ramp.material.diffuseColor = new BABYLON.Color3(0, 0, 0);

			ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, {
			mass: 0,
			restitution: 0.9
			}, scene);

			ramp.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));

			

			ramp.rotation.z = angle;

			ramp.rotation.y = -derivAngle(t, xFn, zFn);

			} 

			function wallAt(xFn, zFn, t, offset, scene) {

			var wall = BABYLON.MeshBuilder.CreateBox('wall', {

			height: 8,

			width: .25,

			depth: 12

			}, scene);

			angle = -derivAngle(t, xFn, zFn); 

			wall.material = new BABYLON.StandardMaterial("wallMaterial", scene);

			wall.material.diffuseColor = new BABYLON.Color3(0, 0, 0);

			wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {

			mass: 0,

			restitution: 0.9

			}, scene);

			wall.position = new BABYLON.Vector3(xFn(t) + (offset * Math.sin(angle)), 4, zFn(t) + (offset * Math.cos(angle)));

			wall.rotation.y = angle + (Math.PI / 2);

			return wall;

			} 
			engine.runRenderLoop(scene.render.bind(scene));
			window.addEventListener('resize', engine.resize.bind(engine)); 

		} //end start

		function lost(){
			alert("you lose!");
			window.location.reload();
			
		} 

				function win(){

		window.location.reload();

		alert("You WIN!");

		} 
    </script>
    <style>
        html, body {
        
        				overflow: hidden;
        
        				width: 100%;
        
        				height: 100%;
        
        				margin: 0;
        
        				padding: 0;
        			}
        			#renderCanvas {
        
        				width: 100%;
        
        				height: 100%;
        
        				touch-action: none;
        
        			}
        			#timer {
position: absolute;
left:10px;
bottom:10px;
color:#ccc;
font: 52px sans-serif;
} 
    </style>
</head>

<body onload="start()">
    <canvas id="renderCanvas"></canvas>

    <div id="timer">00:00</div> 
</body>

</html>